# Requests 项目二次开发指南

## 1. 项目模块分层

Requests 项目采用清晰的分层架构，从用户 API 到底层传输层，每一层都有明确的职责：

### 1.1 分层结构

| 层级 | 模块 | 主要职责 | 文件路径 |
|------|------|----------|----------|
| **API 层** | api.py | 提供用户友好的 HTTP 方法函数 | src/requests/api.py |
| **会话层** | sessions.py | 管理会话状态、连接池和请求配置 | src/requests/sessions.py |
| **请求/响应层** | models.py | 定义请求和响应的数据结构 | src/requests/models.py |
| **传输层** | adapters.py | 处理底层 HTTP 连接和传输 | src/requests/adapters.py |
| **工具层** | utils.py, cookies.py, auth.py 等 | 提供各种辅助功能 | src/requests/utils.py 等 |

### 1.2 核心模块详解

#### 1.2.1 API 层 (api.py)

API 层提供了用户直接调用的 HTTP 方法函数，是用户与库的主要交互入口：

```python
# src/requests/api.py
def get(url, params=None, **kwargs):
    return request("get", url, params=params, **kwargs)

def request(method, url, **kwargs):
    with sessions.Session() as session:
        return session.request(method=method, url=url, **kwargs)
```

#### 1.2.2 会话层 (sessions.py)

会话层管理会话状态、连接池和请求配置，是库的核心组件：

```python
# src/requests/sessions.py
class Session(SessionRedirectMixin):
    def __init__(self):
        self.headers = default_headers()
        self.cookies = cookiejar_from_dict({})
        self.adapters = OrderedDict()
        self.mount("https://", HTTPAdapter())
        self.mount("http://", HTTPAdapter())
    
    def request(self, method, url, **kwargs):
        req = Request(method=method.upper(), url=url, **kwargs)
        prep = self.prepare_request(req)
        resp = self.send(prep, **send_kwargs)
        return resp
```

#### 1.2.3 请求/响应层 (models.py)

请求/响应层定义了请求和响应的数据结构，负责请求的准备和响应的处理：

```python
# src/requests/models.py
class Request(RequestHooksMixin):
    def __init__(self, method=None, url=None, headers=None, files=None, data=None, json=None, params=None, auth=None, cookies=None, hooks=None):
        self.method = method
        self.url = url
        self.headers = headers
        self.files = files
        self.data = data
        self.json = json
        self.params = params
        self.auth = auth
        self.cookies = cookies

class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
    def prepare(self, method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None):
        self.prepare_method(method)
        self.prepare_url(url, params)
        self.prepare_headers(headers)
        self.prepare_cookies(cookies)
        self.prepare_body(data, files, json)
        self.prepare_auth(auth, url)
        self.prepare_hooks(hooks)

class Response:
    @property
    def content(self):
        if self._content is False:
            self._content = b"" .join(self.iter_content(CONTENT_CHUNK_SIZE)) or b""
        self._content_consumed = True
        return self._content
```

#### 1.2.4 传输层 (adapters.py)

传输层处理底层 HTTP 连接和传输，是与 urllib3 交互的桥梁：

```python
# src/requests/adapters.py
class HTTPAdapter(BaseAdapter):
    def __init__(self, pool_connections=DEFAULT_POOLSIZE, pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES, pool_block=DEFAULT_POOLBLOCK):
        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)
    
    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        conn = self.get_connection_with_tls_context(request, verify, proxies=proxies, cert=cert)
        resp = conn.urlopen(
            method=request.method,
            url=url,
            body=request.body,
            headers=request.headers,
            redirect=False,
            assert_same_host=False,
            preload_content=False,
            decode_content=False,
            retries=self.max_retries,
            timeout=timeout,
            chunked=chunked,
        )
        return self.build_response(request, resp)
```

## 2. 主要类/函数作用

### 2.1 API 层函数

| 函数 | 作用 | 参数 | 返回值 | 文件路径 |
|------|------|------|--------|----------|
| `get()` | 发送 GET 请求 | url, params, **kwargs | Response 对象 | src/requests/api.py:62 |
| `post()` | 发送 POST 请求 | url, data, json, **kwargs | Response 对象 | src/requests/api.py:103 |
| `request()` | 通用请求函数 | method, url, **kwargs | Response 对象 | src/requests/api.py:14 |

### 2.2 会话层类/函数

| 类/函数 | 作用 | 主要方法 | 文件路径 |
|---------|------|----------|----------|
| `Session` | 管理会话状态和连接 | request(), send(), prepare_request() | src/requests/sessions.py:356 |
| `session()` | 创建会话上下文 | - | src/requests/sessions.py:819 |

### 2.3 请求/响应层类

| 类 | 作用 | 主要方法 | 文件路径 |
|-----|------|----------|----------|
| `Request` | 表示 HTTP 请求 | prepare() | src/requests/models.py:230 |
| `PreparedRequest` | 表示准备好的请求 | prepare(), prepare_url(), prepare_body() | src/requests/models.py:313 |
| `Response` | 表示 HTTP 响应 | content, text, json(), raise_for_status() | src/requests/models.py:640 |

### 2.4 传输层类

| 类 | 作用 | 主要方法 | 文件路径 |
|-----|------|----------|----------|
| `HTTPAdapter` | 处理 HTTP 连接 | send(), build_response() | src/requests/adapters.py:143 |
| `BaseAdapter` | 适配器基类 | send(), close() | src/requests/adapters.py:113 |

## 3. requests.get() 调用链

### 3.1 完整调用链

1. **用户调用**：`requests.get('https://example.com')`
2. **API 层**：`api.get()` → `api.request()`
3. **会话层**：`Session.request()` → `Session.prepare_request()` → `Session.send()`
4. **请求/响应层**：`Request.prepare()` → `PreparedRequest.prepare()`
5. **传输层**：`HTTPAdapter.send()` → `conn.urlopen()`
6. **底层传输**：urllib3 发送 HTTP 请求
7. **响应处理**：`HTTPAdapter.build_response()` → `Response` 对象

### 3.2 详细步骤分析

#### 步骤 1: 用户调用

```python
import requests
response = requests.get('https://example.com')
```

#### 步骤 2: API 层处理

```python
# src/requests/api.py
def get(url, params=None, **kwargs):
    kwargs.setdefault("allow_redirects", True)
    return request("get", url, params=params, **kwargs)

def request(method, url, **kwargs):
    with sessions.Session() as session:
        return session.request(method=method, url=url, **kwargs)
```

#### 步骤 3: 会话层处理

```python
# src/requests/sessions.py
class Session:
    def request(self, method, url, **kwargs):
        # 创建 Request 对象
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        # 准备请求
        prep = self.prepare_request(req)
        # 发送请求
        resp = self.send(prep, **send_kwargs)
        return resp
    
    def prepare_request(self, request):
        # 合并会话配置和请求配置
        p = PreparedRequest()
        p.prepare(
            method=request.method.upper(),
            url=request.url,
            files=request.files,
            data=request.data,
            json=request.json,
            headers=merge_setting(request.headers, self.headers),
            params=merge_setting(request.params, self.params),
            auth=merge_setting(auth, self.auth),
            cookies=merged_cookies,
            hooks=merge_hooks(request.hooks, self.hooks),
        )
        return p
    
    def send(self, request, **kwargs):
        # 获取适配器
        adapter = self.get_adapter(url=request.url)
        # 发送请求
        r = adapter.send(request, **kwargs)
        # 处理响应
        r = dispatch_hook("response", hooks, r, **kwargs)
        return r
```

#### 步骤 4: 请求准备

```python
# src/requests/models.py
class PreparedRequest:
    def prepare(self, method=None, url=None, headers=None, files=None, data=None, params=None, auth=None, cookies=None, hooks=None, json=None):
        self.prepare_method(method)
        self.prepare_url(url, params)
        self.prepare_headers(headers)
        self.prepare_cookies(cookies)
        self.prepare_body(data, files, json)
        self.prepare_auth(auth, url)
        self.prepare_hooks(hooks)
```

#### 步骤 5: 传输层处理

```python
# src/requests/adapters.py
class HTTPAdapter:
    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        # 获取连接
        conn = self.get_connection_with_tls_context(request, verify, proxies=proxies, cert=cert)
        # 发送请求
        resp = conn.urlopen(
            method=request.method,
            url=url,
            body=request.body,
            headers=request.headers,
            redirect=False,
            assert_same_host=False,
            preload_content=False,
            decode_content=False,
            retries=self.max_retries,
            timeout=timeout,
            chunked=chunked,
        )
        # 构建响应
        return self.build_response(request, resp)
```

## 4. 数据流示意图

### 4.1 文字版数据流图

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   用户代码       │     │    API 层        │     │   会话层        │
│                 │     │                 │     │                 │
│ requests.get()  ├────>│ api.get()       ├────>│ Session.request()│
└─────────────────┘     │ api.request()   │     │                 │
                        └─────────────────┘     └────────┬────────┘
                                                       │
                                                       ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   底层传输       │     │    传输层        │     │   请求/响应层    │
│                 │     │                 │     │                 │
│ urllib3.urlopen()◄────┤ HTTPAdapter.send()◄────┤ PreparedRequest │
│                 │     │                 │     │ .prepare()      │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                       │                       │
        │                       │                       │
        ▼                       ▼                       ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   服务器响应     │     │    响应构建      │     │   响应对象      │
│                 │     │                 │     │                 │
│ HTTP Response   ├────>│ build_response()├────>│ Response 对象   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 4.2 数据流详解

1. **请求发起**：用户调用 `requests.get()` 方法
2. **API 处理**：`api.py` 中的 `get()` 函数调用 `request()` 函数
3. **会话创建**：`request()` 函数创建临时 `Session` 对象
4. **请求构建**：`Session.request()` 创建 `Request` 对象并调用 `prepare_request()`
5. **请求准备**：`PreparedRequest.prepare()` 处理 URL、headers、body 等
6. **连接获取**：`Session.send()` 获取合适的 `HTTPAdapter`
7. **底层传输**：`HTTPAdapter.send()` 通过 urllib3 发送请求
8. **响应接收**：urllib3 接收服务器响应
9. **响应构建**：`HTTPAdapter.build_response()` 创建 `Response` 对象
10. **响应返回**：`Response` 对象被返回给用户

## 5. 代码优化建议

### 5.1 性能优化

1. **使用会话对象**：对于多次请求同一域名的场景，使用 `Session` 对象可以复用连接，提高性能：

```python
# 优化前
for url in urls:
    response = requests.get(url)

# 优化后
with requests.Session() as session:
    for url in urls:
        response = session.get(url)
```

2. **合理使用 stream 参数**：对于大文件下载，使用 `stream=True` 可以避免一次性加载整个响应到内存：

```python
# 优化前
response = requests.get('https://example.com/large-file')
data = response.content

# 优化后
response = requests.get('https://example.com/large-file', stream=True)
with open('file.txt', 'wb') as f:
    for chunk in response.iter_content(chunk_size=8192):
        f.write(chunk)
```

### 5.2 代码结构优化

1. **自定义适配器**：对于特殊的 HTTP 需求，可以继承 `HTTPAdapter` 实现自定义逻辑：

```python
class CustomAdapter(HTTPAdapter):
    def send(self, request, **kwargs):
        # 添加自定义逻辑
        request.headers['X-Custom-Header'] = 'value'
        return super().send(request, **kwargs)

# 使用自定义适配器
session = requests.Session()
session.mount('https://', CustomAdapter())
```

2. **使用钩子**：利用请求/响应钩子可以在不修改核心代码的情况下添加自定义逻辑：

```python
def response_hook(response, **kwargs):
    # 记录响应状态
    print(f"Response status: {response.status_code}")
    return response

# 使用钩子
response = requests.get('https://example.com', hooks={'response': response_hook})
```

## 6. 常见问题与解决方案

### 6.1 连接问题

**问题**：遇到 `ConnectionError` 或 `Timeout` 错误

**解决方案**：
- 设置合理的超时时间：`requests.get(url, timeout=10)`
- 启用重试机制：

```python
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

session = requests.Session()
retries = Retry(total=3, backoff_factor=1, status_forcelist=[500, 502, 503, 504])
session.mount('https://', HTTPAdapter(max_retries=retries))
```

### 6.2 SSL 问题

**问题**：遇到 `SSLError` 或证书验证失败

**解决方案**：
- 对于测试环境，可以临时禁用验证：`requests.get(url, verify=False)`
- 对于生产环境，提供正确的 CA 证书：`requests.get(url, verify='/path/to/cert.pem')`

### 6.3 代理问题

**问题**：需要通过代理访问网络

**解决方案**：
- 设置代理：

```python
proxies = {
    'http': 'http://proxy.example.com:8080',
    'https': 'https://proxy.example.com:8080'
}
response = requests.get(url, proxies=proxies)
```

## 7. 总结

Requests 项目是一个设计精良的 HTTP 客户端库，通过清晰的分层架构和优雅的 API 设计，为开发者提供了简单而强大的 HTTP 请求能力。

- **分层架构**：从 API 层到底层传输层，每一层都有明确的职责
- **核心流程**：`requests.get()` 调用链清晰，从请求构建到响应处理的每一步都可追踪
- **扩展性**：通过会话、适配器和钩子机制，提供了丰富的扩展能力

希望本指南能帮助你更好地理解和二次开发 Requests 项目！